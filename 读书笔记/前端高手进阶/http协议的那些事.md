# HTTP协议的那些事

## 什么是HTTP协议？

```javascript
HTTP协议(超文本传输协议)是浏览器端与服务端之间最主要的通信协议
```

## HTTP/0.9版本

```javascript
  1991年出现，作用是用来传输超文本内容HTML
```

> 传输方式

```javascript
  为客户端发起请求，服务端响应请求的通信方式: 客户端 -> GET/index.html -> 服务端 -> <html>...</html> -> 客户端
```

> HTTP/0.9的不足

```javascript
  只能用来传输文本内容，随着新技术的发展，浏览器希望通过HTTP来传输基本，样式，图片，音视频等其他类型文件
```

## HTTP/1.0

> 核心改变

```javascript
  1996年出现
  1. 新增头部设定，头部内容以键值对的形式设置
  2. 请求头部通过Accept字段来告诉服务端可以接收的请求的文件类型
  3. 响应头部通过Content-Type字段来告诉浏览器返回的文件类型
  4. 很多其他功能也可以依靠头部字段实现，比如缓存，认证
```

> 传输方式

```javascript
  客户端 -> GET/index.html HTTP/1.0 accept:text/css -> 服务端 -> HTTP/1.0 200 OK Content-type: text/css... -> 客户端
```

> 不足

```javascript
  在HTTP/1.0中，每进行一次通信，都需要建立连接、数据传输、断开连接三个阶段，在连接过多时，不停的建立连接和断开连接会增大网络开销
```

## HTTP/1.1

> 核心改变

```javascript
  1999年出现，解决了连接问题，及重复的创建和断开网络连接，增加了一个创建持久连接的方法，主要实现为一个连接传输完成时，并不是马上进行关闭，而是继续复用它传输其他的请求数据，这个连接保持到浏览器或者服务器端断开连接为止
```

> 传输方式

```javascript
  客户端 -> GET/index.html HTTP/1.0 accept:text/css -> 服务端 -> HTTP/1.0 200 OK Content-type: text/css... -> 客户端 -> 下一次请求 GET/index.html HTTP/1.0 accept:text/css -> 服务端 -> HTTP/1.0 200 OK Content-type: text/css... -> ... ->客户端
```

## TCP协议

> 背景

```javascript
  因为HTTP是基于TCP实现的，TCP建立连接以及断开的过程，也就是常常说的'三次握手'和'四次挥手'
```

### 三次握手

- 第一次握手: 客户端处于CLOSED状态，服务端处于LISTEN状态，客户端给服务端发送一个SYN报文，并指明客户端的初始序列号ISN，此时客户端处于SYN_SEND状态
- 第二次握手: 服务端接收到客户端SYN报文，然后以自己的SYN报文作为应答，并指定自己的初始化序列号ISN。同时会把客户端ISN + 1作为ACK值，表示自己已经收到了客户端的SYN，此时服务器处于SYN_REVD状态
- 第三次握手: 客户端收到SYN报文后，会发送一个ACK报文，同时把服务器的ISN + 1作为CK，表示已经收到服务端SYN报文，此时客户端状态为ESTABLISHED状态。服务端收到ACK报文后，也处于ESTABLISHED状态，此时双方成功建立起了连接

<img src='./4.png' width='500' />

> 为什么需要进行三次握手？

- 第一次握手: 握手成功让服务端知道客户端具有发送能力
- 第二次握手: 让客户端知道服务端具有接受和发送能力
- 第三次握手: 让服务端确认客户端收到了自己发送的消息

### 四次挥手

客户端和服务端断开连接时要发送四次数据，这个过程称为四次挥手

- 第一次挥手: 挥手之前确认客户端与服务端都处于ESTABLISHED状态，客户端发送一个FIN报文，用来关闭客户端到服务器的数据传输，此时客户端状态为FIN_WAIT_1状态
- 第二次挥手: 当服务端收到FIN后，会发送ACK报文，并且把客户端的序列号值加1作为ACK报文的序列号值，表示已经收到客户端的报文，此时服务端的状态为CLOSE_WAIT
- 第三次挥手: 如果服务端同意关闭连接，会向客户端发送一个FIN报文，并且指定一个序列号，此时服务端处于LAST_ACK状态
- 第四次挥手: 客户端收到ACK后，出FIN_WAIT_2状态，待收到FIN报文时发送一个ACK报文作为答应，并且把服务端的序列号值加1作为自己ACK报文的序列号值，此时客户端处于TIME_WAIT状态，等待一段时间后会进入CLOSED状态，当服务端收到ACK报文后，也会变为CLOSED状态，此时连接正式关闭

<img src='./5.png' widht='500' />

> 为什么建立连接只通信了三次，而断开连接却用了四次？

- 服务端收到客户端FIN报文后，发送的ACK报文只是用来应答的，并不表示服务端也希望立即关闭
- 只有服务端把所有报文都发送完，才会发送FIN报文，告诉客户端可以断开连接

> HTTP/1.1的不足

```javascript
  虽然通过长连接减少了大量创建/断开连接造成的性能损耗，但是它的并发能力受到限制，所以传输性能还有很大的提升空间
```

## HTTP/2

> 并发能力受限原因

- `浏览器为了减缓服务器的压力`，浏览器限制了同一个域名下HTTP连接数为6-8个，所以在HTTP/1.1下很容易看到资源文件等待加载的情况，对应的优化方式就是使用多个域名来加载资源
- `HTTP/1.1本身的问题`，虽然HTTP/1.1使用了持久连接，但是多个请求公用一个TCP连接，一个连接中同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态，这种情况称为'队头阻塞'

> HTTP/2解决问题的方式？

- `多路复用`
  - 收益于二进制帧，对于同一个域，客户端只需要与服务端建立一个连接即可完成通信需求，也就不受限制于浏览器的连接数了
- `二进制帧`
  - HTTP/2中不在使用ASCII编码传输，而是改为了二进制数据
  - 客户端发送请求时会将美国请求的内容封装成不同带有编号的二进制帧，然后将这些帧同时发送给服务器
  - 服务器接收到数据后，会将相同编号的帧合并为完整的请求信息
  - 服务端返回的结果，客户端接收的结果也遵循这个帧的拆分与组合的过程
- 压缩头部信息来减少传输体积
- 通过服务推送来减少客户端请求

## HTTPS原理

- HTTP满足了通信的要求，但是这种使用明文发送数据的方式存在着一定的安全隐患，通信内容很容易被三方截取甚至篡改
- HTTPS = HTTP + 加密 + 证书机制

### 对称加密

- 对通信数据进行加密
- 对称加密在加密解密过程中使用同一个秘钥
- 性能更好
- 每次通信秘钥会随机生成

### 非对称加密

- 不能保证客户端与服务端同时生成一个相同的秘钥，所以生成的随机秘钥要被传输，对秘钥进行加密
- 客户端通过公钥来加密，服务端利用私钥来解密
- 性能相对差些

### 证书机制

- 一个服务端会对应多个客户端，所以应该有服务端生成秘钥，发送公钥到客户端建立连接
- 发送公钥到客户端的过程也会有安全问题
- 把公钥放入一个证书中，该证书包含服务端的信息，比如颁发者、域名、有效期，为了保证证书是可信的，需要由一个可信的第三方来对证书进行签名。这个第三方一般是证书的颁发机构，也称CA

## HTTP/3

> HTTP1.1与HTTP2存在的问题？

- 在客户端与服务端通信出现丢包时，会阻塞TCP的通信
- HTTP2中，采用二进制帧进行多路复用，一般只有一个TCP连接进行传输，在丢包或者网络问题时，后面的数据都会被阻塞
- HTTP1.1中，可以开启多个TCP连接，任何一个TCP出现问题都不会影响其他的TCP

> HTTP/3的解决方式？

- 底层依赖由TCP改为UDP
- UDP传输时不需要建立连接，可以同时发送多个数据包，效率很高
- 缺点是没有确认机制来保证对方一定能收到数据

## 总结

| 协议版本 | 解决的核心问题           | 解决方式                               |
| -------- | ------------------------ | -------------------------------------- |
| 0.9      | HTML 文件传输            | 确立了客户端请求、服务端响应的通信流程 |
| 1.0      | 不同类型文件传输         | 设立头部字段                           |
| 1.1      | 创建/断开 TCP 连接开销大 | 建立长连接进行复用                     |
| 2        | 并发数有限               | 二进制分帧                             |
| 3        | TCP 丢包阻塞             | 采用 UDP 协议                          |
